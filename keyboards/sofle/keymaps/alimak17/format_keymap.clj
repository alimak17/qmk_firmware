#!/usr/bin/env bb
;; format_keymap.clj
;; Usage: ./format_keymap.clj <input_file> <output_file>
;; Example: ./format_keymap.clj layout.c keymap.c
;;
;; This script reads a QMK layout file (generated by qmk json2c),
;; parses the keymaps array, and re-formats each layer by splitting
;; the keys into rows (12, 12, 12, 14, 10 keys) with extra spacing.
;; It also generates a simple keyboard preview (a text diagram) above each layer.

(ns format-keymap
  (:require [clojure.string :as str]
            [clojure.java.io :as io]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utility Functions

(defn find-matching-paren
  "Given a string s and a start index (pointing just after an opening parenthesis),
   returns the index of the matching closing parenthesis."
  [s start]
  (loop [i start, depth 1]
    (if (< i (count s))
      (let [c (nth s i)]
        (cond
          (= c \() (recur (inc i) (inc depth))
          (= c \)) (if (= depth 1) i (recur (inc i) (dec depth)))
          :else     (recur (inc i) depth)))
      (throw (ex-info "No matching parenthesis found" {})))))

(defn split-keys
  "Splits the content of a LAYOUT(...) macro into individual keys.
   It splits on commas that are not inside nested parentheses."
  [s]
  (let [chars (vec s)]
    (loop [i 0, current "", parts [] , depth 0]
      (if (< i (count chars))
        (let [c (nth chars i)]
          (cond
            (and (= c \,) (zero? depth))
            (recur (inc i) "" (conj parts (str/trim current)) depth)

            (= c \() (recur (inc i) (str current c) parts (inc depth))
            (= c \)) (recur (inc i) (str current c) parts (dec depth))
            :else     (recur (inc i) (str current c) parts depth)))
        (conj parts (str/trim current))))))

(def row-lengths [12 12 12 14 10])
(defn partition-keys
  "Partitions a vector of keys into rows as defined by row-lengths."
  [keys]
  (loop [rows [], ks keys, lengths row-lengths]
    (if (empty? lengths)
      rows
      (let [n (first lengths)
            row (take n ks)
            remaining (drop n ks)]
        (recur (conj rows row) remaining (rest lengths))))))

(defn pad-key
  "Pads a key string to a fixed width for alignment."
  [k]
  (format "%-8s" k))

(defn format-row
  "Formats a single row of keys as a comma‐separated list with padding."
  [row]
  (str "  " (str/join ", " (map pad-key row))))

(defn generate-preview
  "Generates a simple keyboard preview for the given rows.
   Each row is shown with keys separated by vertical bars."
  [rows]
  (let [padded (fn [k] (format "%-8s" k))]
    (->> rows
         (map (fn [row]
                (str "| " (str/join " | " (map padded row)) " |")))
         (str/join "\n"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parsing the Layout File

(defn extract-layers
  "Extracts layers from the input string. Each layer is expected to appear as:
   [n] = LAYOUT( ... ),
   Returns a vector of maps with :layer (the layer number as string)
   and :content (the raw content inside LAYOUT(...))."
  [s]
  (let [pattern (re-pattern "\\[(\\d+)\\]\\s*=\\s*LAYOUT\\(")
        matcher (re-matcher pattern s)]
    (loop [layers []]
      (if (.find matcher)
        (let [layer-num (second (re-groups matcher))
              content-start (.end matcher)
              content-end (find-matching-paren s content-start)
              content (subs s content-start content-end)]
          (recur (conj layers {:layer layer-num :content content})))
        layers))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Formatting Each Layer

(defn format-layer
  "Formats a single layer map into a pretty-printed string.
   It splits the keys, partitions them into rows, and generates a preview."
  [layer-map]
  (let [layer-num (:layer layer-map)
        keys-str  (:content layer-map)
        keys      (split-keys keys-str)
        rows      (partition-keys keys)
        formatted (map format-row rows)
        preview   (generate-preview rows)]
    (str "/* Layer " layer-num " Preview:\n" preview "\n*/\n"
         "    [" layer-num "] = LAYOUT(\n"
         (str/join ",\n" formatted)
         "\n    ),\n\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Main Execution

(def args *command-line-args*)
(when (not= (count args) 2)
  (println "Usage: ./format_keymap.clj <input_file> <output_file>")
  (System/exit 1))

(def input-file  (first args))
(def output-file (second args))

(def content (slurp input-file))
(def layers (extract-layers content))
;; Format each layer; if none found, warn the user.
(when (empty? layers)
  (println "No layers found in the input file.")
  (System/exit 1))

(def formatted-layers (apply str (map format-layer layers)))

(def header (str "/* Generated keymap file with formatted layout and keyboard preview */\n"
                   "#include QMK_KEYBOARD_H\n"
                   "#include \"oled.c\"\n"
                   "#include \"encoder.c\"\n\n"
                   "const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {\n\n"))

(def footer "};\n")

(def output (str header formatted-layers footer))

(spit output-file output)
(println "Formatted keymap written to" output-file)
